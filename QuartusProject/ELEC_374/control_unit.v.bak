`timescale 1ns/10ps
module control_unit (
 output reg Gra, Grb, Grc, Rin, …, Rout, // define the inputs and outputs to your Control Unit
 Yin, Zin, PCout, IncPC, …, MARin,Read, Write, …, Clear,
 ADD, AND, …, SHR,
 input [31:0] IR,
 input Clock, Reset, Stop, …, Con_FF);
 

parameter Reset_state= 8'b00000000, fetch0 = 8'b00000001, fetch1 = 8'b00000010, fetch2= 8'b00000011,
			 add3 = 8'b00000100, add4= 8'b00000101, add5= 8'b00000110, sub3 = 8'b00000111, sub4 = 8'b00001000, sub5 = 8'b00001001,
			 mul3 = 8'b00001010, mul4 = 8'b00001011, mul5 = 8'b00001100, mul6 = 8'b00001101, div3 = 8'b00001110, div4 = 8'b00001111,
			 div5 = 8'b00010000, div6 = 8'b00010001, or3 = 8'b00010010, or4 = 8'b00010011, or5 = 8'b00010100, and3 = 8'b00010101, 
			 and4 = 8'b00010110, and5 = 8'b00010111, shl3 = 8'b00011000, shl4 = 8'b00011001, shl5 = 8'b00011010, shr3 = 8'b00011011,
			 shr4 = 8'b00011100, shr5 = 8'b00011101, rol3 = 8'b00011110, rol4 = 8'b00011111, rol5 = 8'b00100000, ror3 = 8'b00100001,
			 ror4 = 8'b00100010, ror5 = 8'b00100011, neg3 = 8'b00100100, neg4 = 8'b00100101, neg5 = 8'b00100110, not3 = 8'b00100111,
			 not4 = 8'b00101000, not5 = 8'b00101001, ld3 = 8'b00101010, ld4 = 8'b00101011, ld5 = 8'b00101100, ld6 = 8'b00101101, 
			 ld7 = 8'b00101110, ldi3 = 8'b00101111, ldi4 = 8'b00110000, ldi5 = 8'b00110001, st3 = 8'b00110010, st4 = 8'b00110011,
			 st5 = 8'b00110100, st6 = 8'b00110101, st7 = 8'b00110110, addi3 = 8'b00110111, addi4 = 8'b00111000, addi5 = 8'b00111001,
			 andi3 = 8'b00111010, andi4 = 8'b00111011, andi5 = 8'b00111100, ori3 = 8'b00111101, ori4 = 8'b00111110, ori5 = 8'b00111111,
			 br3 = 8'b01000000, br4 = 8'b01000001, br5 = 8'b01000010, br6 = 8'b01000011, br7 = 8'b11111111, jr3 = 8'b01000100, jal3 = 8'b01000101, 
			 jal4 = 8'b01000110, mfhi3 = 8'b01000111, mflo3 = 8'b01001000, in3 = 8'b01001001, out3 = 8'b01001010, nop3 = 8'b01001011, 
			 halt3 = 8'b01001100, fetch2a = 8'b10000000, fetch3 = 8'b11000000; 
 
reg [7:0] present_state = reset_state;  // adjust the bit pattern based on the number of states

always @(posedge Clock, posedge Reset) // finite state machine; if clock or reset rising-edge
 begin
 if (Reset == 1’b1) present_state = reset_state;
 else case (present_state)
	reset_state : present_state = fetch0;
	fetch0 : present_state = fetch1;
	fetch1 : present_state = fetch2;
	fetch2 : begin
					case (IR[31:27]) // inst. decoding based on the opcode to set the next state
						5’b00011 : present_state = add3; // this is the add instruction
						⁞
					endcase
				end
	add3 : present_state = add4;
	add4 : present_state = add5;
	⁞
	endcase
 end
always @(present_state) begin // do the job for each state
	case (present_state) // assert the required signals in each state
		reset_state: begin
			Gra <= 0; Grb <= 0; Grc <= 0; Yin <= 0; // initialize the signals
			⁞
		end
		fetch0: begin
			PCout <= 1; // see if you need to de-assert these signals
			MARin <= 1;
			IncPC <= 1;
			Zin <= 0;
		end
		add3: begin
			 Grb <= 1; Rout <= 1;
			 Yin <= 0;
		end
		⁞
		endcase
	end
endmodule